

# 1. 身份认证模块

## 1.1 登录

**post**  

**url**: `/auth/login`  

**body** 

```json
{
    "username": "Bob",
    "password": "123456"
}
```

**返回结果** 

| code  | msg              | data    |
| ----- | ---------------- | ------- |
| 0     | 成功登陆         | 见示例a |
| 10000 | 用户名或密码错误 | null    |
|       |                  |         |

**示例a**  

```json
{
	"token": "blahblahblah"
}
```

## 1.2 注册

**post**  

**url**: `/auth/register`  

**body**  

```json
{
    "username": "Bob",
    "password": "123456"
}
```

**返回结果**  

| code  | msg                  | data |
| ----- | -------------------- | ---- |
| 10001 | 密码太短或用户名为空 | null |
| 10002 | 用户已存在           | null |
| 0     | 注册成功             | null |
| 10003 | 注册失败             | null |



## 1.3 测试token有效性

**get**  

**url**: `/auth`  

**header**  

| key           | value          |
| ------------- | -------------- |
| Authorization | Bearer {token} |

注意Bearer和token之间有空格  

**返回结果示例**  

```json
{
    "id": 2
}
```

# 2. 匹配模块

## 2.1 查看我的所有预约

**get**
**url**: `/interview/myreservations`

**header**  

| key           | value          |
| ------------- | -------------- |
| Authorization | Bearer {token} |

**返回结果**

| code | msg              | data    |
| ---- | ---------------- | ------- |
| 0    | 获取所有预约成功 | 见示例a |

**示例a**  
```json
[
        {
            "reserveDate": "06/13/2021",/*预约日期*/
            "startTime": "09:00:00",/*预约时间*/
            "endTime": "11:00:00",
            "myId": 7,
            "myName": "ini",
            "companionId": 5, /*匹配者id*/
            "companionName": "rose",
            "myQuizId": 7,/*我分配到的题目id*/
            "myQuizName": "blahblahblah",
            "companionQuizId": 26,/*匹配者分配到的题目id*/
            "companionQuizName": "blahblahblah"
        }
    ]
```



## 2.2 查看从当前开始往后七天的所有预约

**get**
**url**: `/interview/allreservations`
返回结果

| code | msg                               | data    |
| ---- | --------------------------------- | ------- |
| 0    | 成功获取从当前开始7天内的预约消息 | 见示例a |
**示例a**  

```json
[
        {
            "timeId": 7,
            "startTime": "09:00:00",/*面试开始时间*/
            "date": "06/12/2021",
            "count": 0 /*该预约时段队列中的排队者数量*/
        }
    ]
```

## 2.3 点击预约

**post**
**url**: `/interview`
**body**

```json
{
    "timeId": 7,
    "date": "06/13/2021"
}
```

**header**  

| key           | value          |
| ------------- | -------------- |
| Authorization | Bearer {token} |



| code  | msg                                  | data |
| ----- | ------------------------------------ | ---- |
| 0     | 预约成功                             | null |
| 20000 | 预约时间不存在                       | null |
| 20001 | 日期格式不正确，正确格式为MM/dd/yyyy | null |



# 3. 刷题模块

## 3.1 查看所有题目

**get**
**url**: `/quiz`

**参数**: `pageId: int`

| code  | msg                                  | data    |
| ----- | ------------------------------------ | ------- |
| 0     | 获取题目成功                         | 见示例a |
| 30000 | 页号不能为负                         | null    |

**示例a**  

```json
[
        {
            "quizId": 1,
            "quizName": "Peter的烟",
            "content": "Peter 有 nnn 根烟，他每吸完一根烟就把烟蒂保存起来，k(k>1)k(k>1)k(k>1)个烟蒂可以换一个新的烟，那么 Peter 最终能吸到多少根烟呢？",
            "testCaseIn": "4 3",  // 示例输入
            "testCaseOut": "5",  // 示例输出
            "difficulty": "入门",
            "algorithm": "模拟",  
            "categoryId": 316
        }
]
```



## 3.2 查看题目详情

**get**
**url**: `/quiz/concrete`

**参数**: `quizId: int`

| code  | msg          | data    |
| ----- | ------------ | ------- |
| 0     | 获取题目成功 | 见示例a |
| 30001 | 题目不存在   | null    |

**示例a**  

```json
{
        "quizId": 128,
        "quizName": "尼克的任务",
        "content": "尼克每天上班之前都连接上英特网，接收他的上司发来的邮件，这些邮件包含了尼克主管的部门当天要完成的全部任务，每个任务由一个开始时刻与一个持续时间构成。,尼克的一个工作日为 nnn 分钟，从第 111 分钟开始到第 nnn 分钟结束。当尼克到达单位后他就开始干活，公司一共有 kkk 个任务需要完成。如果在同一时刻有多个任务需要完成，尼克可以任选其中的一个来做，而其余的则由他的同事完成，反之如果只有一个任务，则该任务必需由尼克去完成，假如某些任务开始时刻尼克正在工作，则这些任务也由尼克的同事完成。如果某任务于第 ppp 分钟开始，持续时间为 ttt 分钟，则该任务将在第 (p+t−1)(p+t-1)(p+t−1) 分钟结束。,写一个程序计算尼克应该如何选取任务，才能获得最大的空暇时间。",
        "testCaseIn": "15 6\n1 2\n1 6\n4 11\n8 5\n8 1\n11 5",
        "testCaseOut": "4",
        "difficulty": "普及+/提高",
        "algorithm": "动态规划,dp",
        "categoryId": 49
    }
```

## 3.3 提交题目

**post**  

**url**: `/quiz/submit`

**header**  

| key           | value          |
| ------------- | -------------- |
| Authorization | Bearer {token} |

**body**  

```json
{
	"quizId": int
	"code": string
}
```

**返回结果data部分示例**  

```json
"data": {
        "result": "WA",
        "description": ""  // 如果是CE/RE这里会返回编译时/运行时错误信息
 }
```

## 3.4 题目推荐

## 3.5 题目搜索

**get**  

**url**: `/quiz/search`  

**参数**: `q: string`

**返回示例**  

```json
[
  {
            "quizId": 127,
            "quizName": "字串距离",
            "content": "设有字符串 XXX，我们称在 XXX 的头尾及中间插入任意多个空格后构成的新字符串为 XXX 的扩展串，如字符串 XXX 为abcbcd，则字符串abcb□cd，□a□bcbcd□和abcb□cd□ 都是 XXX 的扩展串，这里□代表空格字符。,如果 A1A_1A1​ 是字符串 AAA 的扩展串，B1B_1B1​ 是字符串 BBB 的扩展串，A1A_1A1​ 与 B1B_1B1​ 具有相同的长度，那么我们定义字符串 A1A_1A1​ 与 B1B_1B1​ 的距离为相应位置上的字符的距离总和，而两个非空格字符的距离定义为它们的 ASCII 码的差的绝对值，而空格字符与其他任意字符之间的距离为已知的定值K，空格字符与空格字符的距离为 000。在字符串 AAA、BBB 的所有扩展串中，必定存在两个等长的扩展串 A1A_1A1​，B1B_1B1​，使得 A1A_1A1​ 与 B1B_1B1​ 之间的距离达到最小，我们将这一距离定义为字符串 AAA，BBB 的距离。,请你写一个程序，求出字符串 AAA，BBB 的距离。",
            "testCaseIn": "cmc\nsnmn\n2",
            "testCaseOut": "10",
            "difficulty": "普及+/提高",
            "algorithm": "字符串",
            "categoryId": 82
        }
 ]
```

## 3.6 查看某人对某题的提交记录

**get**  

**url**: `/quiz/submit/record`

**参数**: `quizId: int`  

**header**  

| key           | value          |
| ------------- | -------------- |
| Authorization | Bearer {token} |

**返回示例**  

```json
"data": [
        {
            "submissionId": 4,
            "quizId": 4,
            "userId": 7,
            "code": "#include <iostream>\n using namespace std; int main() {     int a, b, c;     cin >> a >> b >> c;      cout << c + a << endl;     return 0; }",
            "judgeResult": "WA"
        },
        {
            "submissionId": 5,
            "quizId": 4,
            "userId": 7,
            "code": "#include <iostream> using namespace std; int main() {     int a, b, c;     cin >> a >> b >> c;      cout << c + a << endl;     return 0; }",
            "judgeResult": "CE"
        }
]
```

